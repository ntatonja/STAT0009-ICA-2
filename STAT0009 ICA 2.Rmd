---
title: "STAT0009 ICA 2 - Sequential Monte Carlo"
author: '21169367'
date: "11/02/2022"
output: html_document
---
hello
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
One of the most common problems in many areas of Statistics is the problem of intractable integrals and the "curse of dimensionality", i.e. that problems become exponentially harder when extended to two or more dimensions. The Monte Carlo method helps tackling these issues, and is based on the following principle: if an integral can be written as an expectation with respect to some probability distribution, then we can approximate it by drawing samples from the distribution and computing the sample mean (STAT0017 lecture notes). This method works because of two well known theorems from probability theory, the Law of Large Numbers and the Central Limit Theorem.

To present the most basic Monte Carlo method, we took the following example. Y is a random variable following an ex-Gaussian distribution with parameters $\mu=0.4$, $\sigma=0.1$ and $\tau=0.5$. An ex-Gaussian distribution is often used to model response times, and it is defined as the sum of an exponential and a normally distributed variable, and has three parameters: $\mu$, $\sigma$ and $\tau$, which are the mean and standard deviation of the Gaussian variable, and the rate of the exponential variable, respectively. Y represents the time it takes for a person to complete a given task. We want to estimate the probability that it takes more than 3 seconds for a person to complete this task, $p(Y \geq 3)$. To calculate this, we sampled from an ex-Gaussian distribution and calculated the sample mean of the values that were larger than 3.  Sampling from an ex-Gaussian distribution is easy to do in $\texttt{R}$, using the $\texttt{rexGAUS}$ function in the $\texttt{gamlss.dist}$ package.



```{r}
# Sampling - Basic Monte Carlo
library(gamlss.dist)
basic <- rexGAUS(10000,0.4,0.1,0.5)
mean(basic>3)
#exgauss=rnorm(2000,0.4,0.1)+rexp(2000,0.5)
#exgauss[sum(exgauss>3)]/length(exgauss)

exgaussdens <- function(x){
  y <- rep(0,x)
  z <- rep(0,x)
  for (i in 1:x) {
    y[i] <- rexGAUS(1,0.4,0.1,0.5)#rnorm(1,0.4,0.1)+rexp(1,0.5)
    if(y[i]>3) {z[i]=dexGAUS(y[i],0.4,0.1,0.5)
    }
  }
  mean(z[y>3])#sum(z[y>3])/x
}
#plot(density(replicate(10,exgaussdens(2000))))
exgaussdens(2000)

# Very variable
```

## Importance sampling

```{r}

# Importance Sampling - Truncated Normal
IS <- function(n){
  y <- rep(0,n)
  w <- rep(0,n)
  for(i in 1:n){
    yi <- rtruncnorm(1,3,mean = 3,sd=0.1)
    wi <- max( c(dexGAUS(yi,0.4,0.1,0.5)/dtruncnorm(yi,3,mean = 3,sd=0.1), 0), na.rm = T )
    y[i] <- yi
    w[i] <- wi
  }
  #y*w
  return(list(y = y, w = w))
}
#plot(density(replicate(10,IS(2000))))
exgaussis <- IS(2000)
mean(exgaussis$w[exgaussis$y>3])

# Importance Sampling - Truncated Exponential
IS <- function(n){
  y <- rep(0,n)
  w <- rep(0,n)
  for(i in 1:n){
    yi <- rexp(1,0.5)+3
    wi <- dexGAUS(yi,0.4,0.1,0.5)/dexp(yi-3,0.5)
    y[i] <- yi
    w[i] <- wi
  }
  #y*w
  return(list(y = y, w = w))
}
#return(list(y = y, w = w))
#plot(density(replicate(10,IS(2000))))
exgaussis <- IS(2000)
mean(exgaussis$w)
#mean((exgaussis$y*exgaussis$w)[exgaussis$y>3])

IS <- function(n){
  y <- rep(0,length(n))
  w <- rep(0,length(n))
  for(i in 1:n){
    y[i] <- rexp(1,0.5)+3
    if(y[i]>3){w[i] <- dexGAUS(y[i],0.4,0.1,0.5)/dexp(y[i]-3,0.5)}
    else{w[i]<-0}
  }
  w <- w/sum(w)
  return(list(y = y, w = w))
}
# This ain't working
exgaussis <- IS(2000)
mean(exgaussis$w)


w <- function(x) dexGAUS(x,0.4,0.1,0.5)/dexp(x-3,0.5)
#f <- function(x) if(x>3){1}else{0}
# For loop would be needed
X <- rexp(2000,0.5)+3
Y <- w(X)#*f(W)
```

## Sequential Importance Sampling

```{r}
SIS <- function(n,times){
  mu <- rep(0,n)
  sig <- rep(0,n)
  obs <- rep(0,times)
  w <- rep(1/n,n)
  wts <- matrix(0,ncol=times,nrow=n)
  for(i in 1:n){
    mu[i] <- rnorm(1,0,10)
    sig[i] <- runif(1,0,50)
  }
  for(i in 1:times){
    obs[i] <- rnorm(1,mean=5,sd=5) 
  }
  for(i in 1:times) {
    w <- w*dnorm(obs[i],mean=mu,sd=sig)
    w <- w/sum(w)
    wts[,i] <- w
  }
  return(list(postmu = colSums(mu*wts), postsig = colSums(sig*wts)))
}
seqposts <- SIS(200,100)
plot(seqposts$postmu)
plot(seqposts$postsig)
```

## Resampling

```{r}

ReSIS <- function(n,times){
  mu <- rep(0,n)
  sig <- rep(0,n)
  obs <- rep(0,times)
  w <- rep(1/n,n)
  wts <- matrix(0,ncol=times,nrow=n)
  resamplemu <- matrix(0,ncol=n,nrow=times+1)
  resamplesig <- matrix(0,ncol=n,nrow=times+1)
  for(i in 1:n){
    mu[i] <- rnorm(1,0,10)
    sig[i] <- runif(1,0,50)
  }
  resamplemu[1,] <- mu
  resamplesig[1,] <- sig
  for(i in 1:times) {
    obs[i] <- rnorm(1,mean=5,sd=5)
    wt <- w*dnorm(obs[i],mean=resamplemu[i,],sd=resamplesig[i,])
    wt <- wt/sum(wt)
    #wts[,i] <- wt
    resamplemu[i+1,] <- sample(resamplemu[i,], n, replace = T, prob = wt)
    resamplesig[i+1,] <- sample(resamplesig[i,], n, replace = T, prob = wt)
  }
  return(list(postmu = rowMeans(resamplemu), postsig = rowMeans(resamplesig)))
  #return(list(postmu = colSums(mu*wts), postsig = colSums(sig*wts)))
}
seqposts <- ReSIS(20000,100)
plot(seqposts$postmu)
plot(seqposts$postsig)

```